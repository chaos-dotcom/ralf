use crate::completions;
use crate::paths;
use anyhow::Result;
use regex::Regex;
use std::fs;
use std::path::Path;

enum State {
    Simple,
    Nested,
}

pub fn generate_config() -> Result<String> {
    let p = paths::find_config_or_exit()?;
    let text = crate::config_merge::load_and_merge(&p)?;
    let re = Regex::new(r"^( *)([A-Za-z0-9\-]+): *(.+)$")?;

    let mut out = String::new();

    // Header (bash parity)
    out.push_str("# This file was automatically generated by ralf\n");
    out.push_str("# https://github.com/dannyben/ralf\n");

    let mut lastcmd: Option<String> = None;
    let mut state = State::Simple;
    let mut case_open = false;

    for line in text.lines() {
        if let Some(caps) = re.captures(line) {
            let indent = caps.get(1).unwrap().as_str();
            let alias = caps.get(2).unwrap().as_str().to_string();
            let mut cmd = caps.get(3).unwrap().as_str().to_string();

            if indent.is_empty() {
                // Flush previous alias block
                generate_last_cmd(&mut out, lastcmd.take(), &mut state, &mut case_open);

                // Rewrite self-referencing commands
                let local_re = Regex::new(&format!(r"^{}( +|$)", regex::escape(&alias)))?;
                if local_re.is_match(&cmd) {
                    cmd = format!("command {}", cmd);
                }

                out.push_str(&format!(
                    "\nunalias {} 1>/dev/null 2>&1\n{}() {{\n",
                    alias, alias
                ));
                lastcmd = Some(cmd);
            } else {
                // Nested subcommand
                if let State::Simple = state {
                    out.push_str("  case \"$1\" in\n");
                    state = State::Nested;
                    case_open = true;
                }

                let ali2 = alias;
                let cmd2 = cmd.clone();

                out.push_str(&format!("    {})\n      shift\n", ali2));

                let parent = lastcmd.as_ref().cloned().unwrap_or_default();
                let combined = if cmd2.starts_with('!') {
                    cmd2[1..].to_string()
                } else if parent.starts_with('!') {
                    cmd2.clone()
                } else {
                    format!("{} {}", parent, cmd2)
                };

                if cmd2.contains('$') {
                    out.push_str(&format!("      {}\n", combined));
                } else {
                    out.push_str(&format!("      {} \"$@\"\n", combined));
                }

                out.push_str("      ;;\n");
            }
        }
    }

    // Flush trailing
    generate_last_cmd(&mut out, lastcmd.take(), &mut state, &mut case_open);

    // Blank line then completions (from merged text) if any
    out.push('\n');
    if has_subcommands_text(&text) {
        out.push_str(&completions::generate_completions_from_text(&text)?);
    }

    Ok(out)
}

fn generate_last_cmd(
    out: &mut String,
    lastcmd: Option<String>,
    state: &mut State,
    _case_open: &mut bool,
) {
    let Some(last) = lastcmd else { return };
    let fullcmd = if last.starts_with('!') {
        "echo this alias requires a subcommand".to_string()
    } else if last.contains('$') {
        last
    } else {
        format!("{last} \"$@\"")
    };

    match state {
        State::Simple => {
            out.push_str(&format!("  {}\n}}\n", fullcmd));
        }
        State::Nested => {
            out.push_str("    *)\n");
            out.push_str(&format!("      {}\n", fullcmd));
            out.push_str("      ;;\n");
            out.push_str("  esac\n");
            out.push_str("}\n");
            *state = State::Simple;
        }
    }
}

#[allow(dead_code)]
pub fn has_subcommands(config_file: &Path) -> Result<bool> {
    let re = Regex::new(r"^ +([a-z0-9\-]+):")?;
    let text = fs::read_to_string(config_file)?;
    Ok(text.lines().any(|l| re.is_match(l)))
}

fn has_subcommands_text(text: &str) -> bool {
    let re = regex::Regex::new(r"^ +([a-z0-9\-]+):").unwrap();
    text.lines().any(|l| re.is_match(l))
}
