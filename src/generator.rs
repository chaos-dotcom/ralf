use crate::completions;
use crate::paths;
use anyhow::Result;
use regex::Regex;
use std::fs;
use std::path::Path;

enum State {
    Simple,
    Nested,
}

pub fn generate_config() -> Result<String> {
    let p = paths::find_config_or_exit()?;
    let text = crate::config_merge::load_and_merge(&p)?;
    let is_fish = std::env::var("FISH_VERSION").is_ok()
        || std::env::var("SHELL")
            .ok()
            .map(|s| s.ends_with("fish") || s.contains("/fish"))
            .unwrap_or(false)
        || {
            let s = p.aliases_file.to_string_lossy();
            s.ends_with(".fish") || s.contains("/fish/")
        };
    if is_fish {
        generate_config_fish_from_text(&text)
    } else {
        generate_config_sh_from_text(&text)
    }
}

fn generate_config_sh_from_text(text: &str) -> Result<String> {
    let re = Regex::new(r"^( *)([A-Za-z0-9\-]+): *(.+)$")?;
    let mut out = String::new();
    out.push_str("# This file was automatically generated by ralf\n");
    out.push_str("# https://github.com/dannyben/ralf\n");
    let mut lastcmd: Option<String> = None;
    let mut state = State::Simple;
    let mut case_open = false;
    for line in text.lines() {
        if let Some(caps) = re.captures(line) {
            let indent = caps.get(1).unwrap().as_str();
            let alias = caps.get(2).unwrap().as_str().to_string();
            let mut cmd = caps.get(3).unwrap().as_str().to_string();
            if indent.is_empty() {
                generate_last_cmd(&mut out, lastcmd.take(), &mut state, &mut case_open);
                let local_re = Regex::new(&format!(r"^{}( +|$)", regex::escape(&alias)))?;
                if local_re.is_match(&cmd) {
                    cmd = format!("command {}", cmd);
                }
                out.push_str(&format!("\nunalias {} 1>/dev/null 2>&1\n{}() {{\n", alias, alias));
                lastcmd = Some(cmd);
            } else {
                if let State::Simple = state {
                    out.push_str("  case \"$1\" in\n");
                    state = State::Nested;
                    case_open = true;
                }
                let ali2 = alias;
                let cmd2 = cmd.clone();
                out.push_str(&format!("    {})\n      shift\n", ali2));
                let parent = lastcmd.as_ref().cloned().unwrap_or_default();
                let combined = if cmd2.starts_with('!') {
                    cmd2[1..].to_string()
                } else if parent.starts_with('!') {
                    cmd2.clone()
                } else {
                    format!("{} {}", parent, cmd2)
                };
                if cmd2.contains('$') {
                    out.push_str(&format!("      {}\n", combined));
                } else {
                    out.push_str(&format!("      {} \"$@\"\n", combined));
                }
                out.push_str("      ;;\n");
            }
        }
    }
    generate_last_cmd(&mut out, lastcmd.take(), &mut state, &mut case_open);
    out.push('\n');
    if has_subcommands_text(&text) {
        out.push_str(&crate::completions::generate_completions_from_text(&text)?);
    }
    Ok(out)
}

fn generate_config_fish_from_text(text: &str) -> Result<String> {
    let re = Regex::new(r"^( *)([A-Za-z0-9\-]+): *(.+)$")?;
    let mut out = String::new();
    out.push_str("# This file was automatically generated by ralf\n");
    out.push_str("# https://github.com/dannyben/ralf\n");
    let mut lastcmd: Option<String> = None;
    enum FState { Simple, Nested }
    let mut state = FState::Simple;
    let needs_bash_shim = |s: &str| {
        s.contains("${") || s.contains("$(") || s.contains('`') || s.contains("[[") || s.contains("]]") || s.contains("&&") || s.contains("||")
    };
    let has_fish_arg_ref = |s: &str| s.contains("$argv") || s.contains("$rest");
    let sq = |s: &str| s.replace('\'', "'\"'\"'");
    for line in text.lines() {
        if let Some(caps) = re.captures(line) {
            let indent = caps.get(1).unwrap().as_str();
            let alias = caps.get(2).unwrap().as_str().to_string();
            let mut cmd = caps.get(3).unwrap().as_str().to_string();
            if indent.is_empty() {
                // Flush previous function
                if let Some(last) = lastcmd.take() {
                    let fullcmd = if last.starts_with('!') {
                        "echo this alias requires a subcommand".to_string()
                    } else if needs_bash_shim(&last) {
                        let script = format!("{last} \"$@\"");
                        format!("bash -lc '{}' -- $argv", sq(&script))
                    } else if has_fish_arg_ref(&last) {
                        last
                    } else {
                        format!("{last} $argv")
                    };
                    match state {
                        FState::Simple => {
                            out.push_str(&format!("  {}\nend\n", fullcmd));
                        }
                        FState::Nested => {
                            out.push_str("    case '*'\n");
                            out.push_str(&format!("      {}\n", fullcmd));
                            out.push_str("  end\n");
                            out.push_str("end\n");
                            state = FState::Simple;
                        }
                    }
                }
                // Rewrite self-referencing commands
                let local_re = Regex::new(&format!(r"^{}( +|$)", regex::escape(&alias)))?;
                if local_re.is_match(&cmd) {
                    cmd = format!("command {}", cmd);
                }
                out.push_str(&format!("\nfunctions -q {0}; and functions -e {0}\nfunction {0}\n", alias));
                lastcmd = Some(cmd);
            } else {
                if let FState::Simple = state {
                    out.push_str("  switch $argv[1]\n");
                    state = FState::Nested;
                }
                let ali2 = alias;
                let cmd2 = cmd.clone();
                out.push_str(&format!("    case {}\n", ali2));
                out.push_str("      set -l rest $argv[2..-1]\n");
                let parent = lastcmd.as_ref().cloned().unwrap_or_default();
                let combined = if cmd2.starts_with('!') {
                    cmd2[1..].to_string()
                } else if parent.starts_with('!') {
                    cmd2.clone()
                } else {
                    format!("{} {}", parent, cmd2)
                };
                let bashy = needs_bash_shim(&combined);
                if bashy {
                    let script = format!("{combined} \"$@\"");
                    out.push_str(&format!("      bash -lc '{}' -- $rest\n", sq(&script)));
                } else if has_fish_arg_ref(&combined) {
                    out.push_str(&format!("      {}\n", combined));
                } else {
                    out.push_str(&format!("      {} $rest\n", combined));
                }
            }
        }
    }
    // Flush trailing
    if let Some(last) = lastcmd.take() {
        let fullcmd = if last.starts_with('!') {
            "echo this alias requires a subcommand".to_string()
        } else if needs_bash_shim(&last) {
            let script = format!("{last} \"$@\"");
            format!("bash -lc '{}' -- $argv", sq(&script))
        } else if has_fish_arg_ref(&last) {
            last
        } else {
            format!("{last} $argv")
        };
        match state {
            FState::Simple => {
                out.push_str(&format!("  {}\nend\n", fullcmd));
            }
            FState::Nested => {
                out.push_str("    case '*'\n");
                out.push_str(&format!("      {}\n", fullcmd));
                out.push_str("  end\n");
                out.push_str("end\n");
            }
        }
    }
    out.push('\n');
    if has_subcommands_text(&text) {
        out.push_str(&crate::completions::generate_fish_completions_from_text(&text)?);
    }
    Ok(out)
}

fn generate_last_cmd(
    out: &mut String,
    lastcmd: Option<String>,
    state: &mut State,
    _case_open: &mut bool,
) {
    let Some(last) = lastcmd else { return };
    let fullcmd = if last.starts_with('!') {
        "echo this alias requires a subcommand".to_string()
    } else if last.contains('$') {
        last
    } else {
        format!("{last} \"$@\"")
    };

    match state {
        State::Simple => {
            out.push_str(&format!("  {}\n}}\n", fullcmd));
        }
        State::Nested => {
            out.push_str("    *)\n");
            out.push_str(&format!("      {}\n", fullcmd));
            out.push_str("      ;;\n");
            out.push_str("  esac\n");
            out.push_str("}\n");
            *state = State::Simple;
        }
    }
}

#[allow(dead_code)]
pub fn has_subcommands(config_file: &Path) -> Result<bool> {
    let re = Regex::new(r"^ +([a-z0-9\-]+):")?;
    let text = fs::read_to_string(config_file)?;
    Ok(text.lines().any(|l| re.is_match(l)))
}

fn has_subcommands_text(text: &str) -> bool {
    let re = regex::Regex::new(r"^ +([a-z0-9\-]+):").unwrap();
    text.lines().any(|l| re.is_match(l))
}
